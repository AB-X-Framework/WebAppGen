<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Tetris in Pure JS</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background: #111;
        }

        .tetris {
            display: grid;
            grid-template-rows: repeat(20, 30px);
            grid-template-columns: repeat(10, 30px);
            gap: 1px;
            background: #333;
        }

        .cell {
            width: 30px;
            height: 30px;
            background: #111;
        }

        .active {
            background-color: cyan;
        }

        .taken {
            background-color: #666;
        }

        h1 {
            position: absolute;
            top: 20px;
            color: white;
            font-family: sans-serif;
        }
    </style>
</head>
<body>
<h1>Tetris (Pure JS)</h1>
<div class="tetris" id="grid"></div>

<script>
    const grid = document.getElementById("grid");
    const width = 10;
    const height = 20;
    const cells = [];

    // Create grid cells
    for (let i = 0; i < width * height; i++) {
        const cell = document.createElement("div");
        cell.classList.add("cell");
        grid.appendChild(cell);
        cells.push(cell);
    }

    const tetrominoes = [
        [1, width + 1, width * 2 + 1, 2], // L
        [0, width, width + 1, width * 2 + 1], // Z
        [1, width, width + 1, width + 2], // T
        [0, 1, width, width + 1], // O
        [1, width + 1, width * 2 + 1, width * 3 + 1], // I
    ];

    let currentPosition = 4;
    let current = tetrominoes[Math.floor(Math.random() * tetrominoes.length)];
    let timer = null;

    function draw() {
        current.forEach(index => {
            cells[currentPosition + index].classList.add("active");
        });
    }

    function undraw() {
        current.forEach(index => {
            cells[currentPosition + index].classList.remove("active");
        });
    }

    function moveDown() {
        undraw();
        currentPosition += width;
        if (checkCollision()) {
            currentPosition -= width;
            freeze();
            return;
        }
        draw();
    }

    function moveLeft() {
        undraw();
        const isAtLeftEdge = current.some(index => (currentPosition + index) % width === 0);
        if (!isAtLeftEdge) currentPosition--;
        if (checkCollision()) currentPosition++;
        draw();
    }

    function moveRight() {
        undraw();
        const isAtRightEdge = current.some(index => (currentPosition + index) % width === width - 1);
        if (!isAtRightEdge) currentPosition++;
        if (checkCollision()) currentPosition--;
        draw();
    }

    function rotate() {
        undraw();
        const prev = current;
        current = current.map(index => {
            const x = index % width;
            const y = Math.floor(index / width);
            return (x - y) + width * x;
        });
        if (checkCollision()) current = prev;
        draw();
    }

    function checkCollision() {
        return current.some(index => {
            const next = currentPosition + index;
            return next >= width * height || cells[next].classList.contains("taken");
        });
    }

    function freeze() {
        current.forEach(index => cells[currentPosition + index].classList.add("taken"));
        currentPosition = 4;
        current = tetrominoes[Math.floor(Math.random() * tetrominoes.length)];
        if (checkCollision()) {
            clearInterval(timer);
            alert("Game Over!");
        }
    }

    function control(e) {
        if (e.key === "ArrowLeft") moveLeft();
        else if (e.key === "ArrowRight") moveRight();
        else if (e.key === "ArrowDown") moveDown();
        else if (e.key === "ArrowUp") rotate();
    }

    document.addEventListener("keydown", control);

    draw();
    timer = setInterval(moveDown, 1000);
</script>
</body>
</html>
